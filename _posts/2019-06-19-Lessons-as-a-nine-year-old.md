---
title: Lessons as a Nine-Year-Old
description: Reflections on learning and growth
date: 2019-06-19 05:00:00 -0500
categories: [post]
tags: [self-improvement, coding, learning, problem-solving, minecraft]
pin: false
math: true
mermaid: true
image: assets/2019-06-19-Lessons-as-a-nine-year-old.jpg
---

What was my one goal in life as a nine year old? To download hacks (otherwise know as cheats) in Minecraft. I said to myself "If I can get hacks, I can do anything".
This was probably my first attempt at understanding code and computers. As simple as downloading a modpack was - **I simply did not know how to do it and would have to learn**.

I now take this philosophy to every area of my life. If I don't know how to do it? Learn it. If I can't do it? Do it. If I can't be it? Be it.

## 2026 Addition

I still barely know how to code or the detailed mechanism of repository development or maintenance but I am able to use and modify the tools other have created.
At-least for me the real reason Large-Language-Models have become so effective is that most of the single-task user applications I want to build have an easy way of getting prompted. Aka, I am the perfect match for vibe coding. It has become significantly easier to build simple tools and significantly easier to diagnose something someone else built is not learning.
While I can take the time to learn the fundamentals of computer science the need for that knowledge is not there due to how and what task I need to be completed. In a way I am "losing" my ability to code but I never really wanted to code in the first place, I wanted to solve problem - an essential pillar of a software developer.

[A quote originally found on Simon Willison's blog](https://lobste.rs/s/x1xqtv/llms_are_not_fun#c_xccjtq):
> I’ve been very outspoken in support of agentic coding tools, both here and elsewhere, but I still don’t fully buy this analogy. I don’t feel like I’m puzzling any less. If anything, I’m spending more time on the part I actually enjoy: figuring out how to solve a problem, together with a very capable machine that can reason through it with me. The puzzle is still there. What’s gone is the labor. I never enjoyed hitting keys, writing minimal repro cases with little insight, digging through debug logs, or trying to decipher some obscure AWS IAM permission error. That work wasn’t the puzzle for me. It was just friction, laborious and frustrating. The thinking remains; the hitting of the keys and the frustrating is what’s been removed.

I don't like solving why I have to run python 3.11 instead of python 3.13 because of dependency issues. I want python to work so I can usually use the tool it's running.
